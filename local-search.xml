<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录美好的一天天~</title>
    <link href="/2023/03/27/zxt/"/>
    <url>/2023/03/27/zxt/</url>
    
    <content type="html"><![CDATA[<h6 id="2023-4-1（台州临海）"><a href="#2023-4-1（台州临海）" class="headerlink" title="2023.4.1（台州临海）"></a>2023.4.1（台州临海）</h6><p>​1.一大早开着我的特特和我的baby出发啦111~</p><img src="images/zxt/7a54b8e82b31b04b91abecd50ec9de8.jpg" alt="7a54b8e82b31b04b91abecd50ec9de8" width="300"  /><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JaveWeb</title>
    <link href="/2023/03/27/JaveWeb/"/>
    <url>/2023/03/27/JaveWeb/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>制作中小型网站&amp;企业管理系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础</title>
    <link href="/2023/03/27/Java/"/>
    <url>/2023/03/27/Java/</url>
    
    <content type="html"><![CDATA[<p>1、JDK：Java开发工具包，包括JVM虚拟机，核心类库，开发工具。JRE：Java运行环境。JDK包含了JRE，JRE包含了JVM。</p></br><p>2、class：创建&#x2F;定义一个类，类是Java最基本的组成单元。</p></br><p>3、计算机三原色：红、绿、蓝&#x3D;》rbg。</p></br><p>4、数据类型：</p><p>​整型：byte、short、int（默认）、long。定义long类型的变量，在数值后面需要加一个L作为后缀，可以大写也可以小写。</p><p>​浮点数：float、double（默认），float后缀同理要加一个F</p><p>​字符：char　　　　　　　布尔：Boolean</p></br><p>5、Java键盘录入的类：Scanner。</p></br><p>6、byte、short、char三种类型数据在运算时，会先提升为int，在进行运算</p></br><p>7、数组初始化：</p><p>​静态初始化：int[] arr&#x3D;{1,2,3,4,5}</p><p>​动态初始化：int[] arr&#x3D;new int[5]  -&gt;代表五个</p></br><p>8、方法重载：方法名相同，参数类型或个数不同。Java虚拟机会通过参数不同来区分同名的方法。</p></br><p>9、类名首字母建议大写。</p></br><p>10、封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为。例子：人画圆，画圆事件封装在圆对象上。</p></br><p>11、private关键词：是一个权限修饰符，可以修饰成员（成员变量和方法），被private修饰的成员只能在本类中才能访问。对象内部通过get和set进行变量操作。</p></br><p>12、构造方法推荐使用方式：无论是否使用，都手动书写无参构造方法和带全部参数的构造方法。（IDEA快捷创建：alt+insert指令。）</p></br><p>13、比较字符串对象中的内容是否相等：equals(完全一样)，equalsIgnoreCase(忽略大小写)</p></br><p>14、统计一个字符串中有多少大写字符、小写字符、数字字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> bigCount=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> smallCount=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> numberCount=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length();i++)&#123;<br>    <span class="hljs-type">char</span> c=str.charAt(i);<br>    <span class="hljs-comment">//char类型的变量在参与计算的时候自动类型提升为int，查询ascii码表</span><br>    <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>        smallCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>        bigCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>        numberCount++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>15、StringBuilder：可以看成是一个容器，创建之后里面的内容是可变的（String定义后的字符串不可变）</p><p>​作用：提高字符串的操作效率。</p><p>StringBuilder是Java已经写好的类，打印对象不是地址值而是属性值。</p><p>最后要用toString()方法把StringBuilder变回字符串。</p><p>使用场景：字符串的拼接、字符串的反转。</p></br><p>​<strong>String对象的改变，实际上是通过内存地址的“断开-连接”变化来完成的。在这个过程中，原字符串中的内容并没有发生任何的改变。String s &#x3D; “yiyige” 和 s &#x3D; “yyg”这两行代码，实质上是开辟了2个内存空间，s只是由原来指向 “yiyige” 变为指向 “yyg” 而已，而其原来的字符串内容，是没有发生改变的。</strong></p><p>​<strong>所以String的不可变，其实是指value在栈中的引用地址不可变，而不是说常量池中value字符数组里的数据元素不可变。也就是说，value所引用的数组对象里的内容，其实是可以发生改变的。</strong></p><p>​<strong>String字符串的内容其实是可变的，不可改变的只是String字符串的对象地址。</strong></p><p>​<strong>因此，我们在以后的开发中，如果要经常修改字符串的内容，请尽量少用String！因为如果字符串的指向经常的“断开-连接”，就会大大降低性能，我建议大家使用StringBuilder 或 StringBuffer 进行替换。</strong></p></br><p>16、集合和数组的区别：</p><p>​1、数组长度固定，集合长度可变。</p><p>​2、数组可以存储引用数据类型和基本数据类型，集合只能存储引用数据类型，要想存储基本数据类型，需要将基本数据类型转化成对应的包装类。</p><p>​泛型：限定集合中存储数据的类型。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <span class="hljs-comment">//JDK7以前的写法</span><br><br>ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//JDK7以后的写法，可以省略后面的类型，&lt;&gt;要写</span><br><br><span class="hljs-comment">//添加元素，返回一个Boolean，永远为true</span><br>list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>list.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>list.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-comment">//删除元素</span><br>list.remove(<span class="hljs-string">&quot;aaa&quot;</span>);  <span class="hljs-comment">//删除成功返回true，失败返回false</span><br>list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">//根据索引删除元素，返回被删除的元素</span><br><span class="hljs-comment">//修改元素</span><br>list.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ddd&quot;</span>);  <span class="hljs-comment">//返回被修改的元素</span><br><span class="hljs-comment">//查询元素</span><br>list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回被查询的元素</span><br><span class="hljs-comment">//获取长度</span><br>list.size();<br><br></code></pre></td></tr></table></figure></br><p>17、基本数据类型对应的包装类</p><p>​byte-&gt;Byte　　 　short-&gt;Short 　　　<strong>char-&gt;Character　　　 int-&gt;Integer</strong> 　　　long-&gt;Long 　　　float-&gt;Float 　double-&gt;Double 　　boolean-&gt;Boolean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>ArrayList&lt;Character&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></br><p>18、static特点：被该类所有对象共享，<strong>不属于对象，属于类</strong>，<strong>随着类的加载而加载，优先于对象存在</strong>。</p><p>调用方式：推荐使用类名调用，也可以对象名调用。</p></br><p>19、继承：Java只支持<strong>单继承</strong>，不支持<strong>多继承</strong>，但支持<strong>多层继承</strong>：子类A继承父类B，子类B继承父类C。</p><p>Java中所有的类都直接或者间接继承于<strong>Object</strong>类。子类只能访问父类非私有的成员。</p><p>父类的构造方法不能被子类继承。</p><p>父类的成员变量无论是否私有，在子类中都可以<strong>继承</strong>下来，但是<strong>如果是父类的私有成员变量，子类无法调用</strong>。</p><p>父类的成员方法只有在<strong>虚方法表</strong>中才能把被子类继承。</p><p>虚方法表：非private，非static，非final修饰的方法。</p><p>继承中成员变量访问特点：<strong>就近原则。</strong>现在局部位置找，本类成员位置找，父类成员位置找，逐级往上。</p><p>super关键字：直接去父类中找成员变量或方法。</p></br><p>20、方法重写：子类出现了和父类一模一样的方法生命，我们就称子类这个方法是重写的方法。</p><p>建议重写方法都加**@Override<strong>注解。</strong>只有被添加到虚方法表中的方法才能被重写。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>    sout(<span class="hljs-string">&quot;zzz&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>21、子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。</p><p>原因：子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成吃实话，子类将无法使用父类的数据。因此子类初始化前，一定要调用父类构造方法先完成父类数据空间的初始化。</p><p><strong>子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行。</strong></p></br><p>22、多态：对象的多种形态。</p><p>前提：有继承&#x2F;实现关系。有父类引用指向子类对象。有方法的重写。</p><p>好处：<strong>使用父类型作为参数，可以接收所有子对象。</strong>体现多态的扩展性与便利。</p><p>弊端：不能使用子类的特有功能。</p><p>解决方法：自动类型转换、强制类型转换，可以转换成真正的子类类型，从而调用子类独有功能。</p><p>转换类型与真实对象类型不一致会报错。</p><p>转换的时候用instanceof关键字进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//自动类型转换</span><br>Student s=(Student) p;   <span class="hljs-comment">//强制类型转换</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多态形式创建对象</span><br>Fu f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br><span class="hljs-comment">//调用成员变量的特点：编译看左边，运行也看左边。</span><br><span class="hljs-comment">//调用成员方法的特点：编辑看左边，运行看右边。</span><br><span class="hljs-comment">//编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量或方法，如果有，编辑成功，如果没有，编辑失败。</span><br><span class="hljs-comment">//运行看左边：java运行代码的时候，实际获取的是左边父类中成员变量的值。</span><br><span class="hljs-comment">//运行看右边；java运行代码的时候，实际上运行的是子类中的方法。</span><br><br><span class="hljs-comment">//理解：Animal A=new Dog();</span><br><span class="hljs-comment">//现在用a去调用变量和方法？是的</span><br><span class="hljs-comment">//而a是Animal类型的，所以默认都会从Animal这个类中找</span><br><br><span class="hljs-comment">//成员变量：在子类的对象中，会把父类的成员变量也继承下来。父：name,子：name</span><br><span class="hljs-comment">//成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的。</span><br><br></code></pre></td></tr></table></figure></br><p>23、使用同一个包中的类时，不需要导包。</p><p>使用java.lang包中的类时，不需要导包。</p><p>其他情况都需要导包。</p><p>如果同时用两个包中的同名类，需要用全类名。</p></br><p>24、final关键词：</p><p>修饰方法：表明该方法时最终方法，不能被重写。</p><p>类：表明该类时最终类，不能被继承。</p><p>变量：叫做常量，只能被赋值一次。</p><p>final修饰基本数据类型，记录的值不能发生改变，修饰引用数据类型，记录的地址值不能发生变化，内部的属性值是可以改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Student S=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">14</span>)；<br>S=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sutdent</span>();  <span class="hljs-comment">//会报错</span><br>S.setName(<span class="hljs-string">&quot;李四&quot;</span>);  <span class="hljs-comment">//不会报错，并且可以修改成功。</span><br></code></pre></td></tr></table></figure></br><p>25、权限修饰符分类 </p><p>四种作用范围从小到大（private&lt;空着不写&lt;protected&lt;public）</p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中其他类</th><th>不同包下的子类</th><th>不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>空着不写</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></br><p>26、静态代码块作用：数据初始化。</p></br><p>27、抽象方法：</p><p>​将<strong>共性的</strong>行为（方法）抽取到父类之后。</p><p>​由于每一个子类执行的内容是不一样。</p><p>​所以，在父类中不能确定<strong>具体的方法体</strong>。</p><p>​该方法就可以定义为抽象方法。</p><p>抽象类：如果一个<strong>类中存在抽象方法</strong>，那么该类就<strong>必须声明为抽象类</strong></p><p>抽象类不能实例化。</p></br><p>28、接口：就是一种规则，是对行为的抽象。</p><p>用关键词interface来定义。 public interface 接口名{}</p><p>接口不能实例化。接口和类之间是实现关系，通过implements关键词表示。</p><p>public class 类名 implements 接口名{}</p><p>接口和类的实现关系，可以单实现也可以多实现。</p><p>public class 类名 implements 接口名1，接口名2{}</p><p>实现类还可以在继承一个类的同时实现多个接口。</p><p>public class 类名 extends 父类 implements 接口名1，接口名2{}</p></br><p>29、接口中成员的特点：</p><p>成员变量：只能是常量。默认修饰符：public static final</p><p>构造方法：没有。</p><p>成员方法：只能是抽象方法，默认修饰符：public abstract</p></br><p>30、类和类的关系：继承关系，只能单继承，但可以多层继承。</p><p>类和接口的关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口。</p><p>接口和接口的关系：继承关系，可以单继承，也可以多继承。</p></br><p>31、JDK8以前，接口只能定义抽象方法。JDK8<strong>允许在接口中定义默认方法和静态方法，需要使用关键词default和static修饰。</strong>作用：<strong>解决接口升级的问题</strong>。JDK9允许接口定义私有方法，分为普通的私有方法（为default默认方法服务）和静态的私有方法（为static静态方法服务），作用：抽取重复代码并在接口内部使用，不让外部访问。</p><p>接口中默认方法的定义格式：</p><ol><li>格式：public default 返回值类型 方法名（参数列表）{}</li><li>范例：public default void show（）{}</li></ol><p>接口中默认方法的注意事项：</p><ol><li>默认方法不是抽象方法，所以不强制被重写，但如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略，不写的话会被默认当成抽象方法。</li><li>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></br><p>32、当一个方法参数是接口时，可以传递接口<strong>所有实现类的对象</strong>，这种方式称之为接口多态。</p></br><p>33、内部类：在一个类中又定义了一个类。</p><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。</p><p>特点：内部类可以直接访问外部类的成员，包括私有。外部类要访问内部类的成员，必须创建对象。</p></br><p>34、获取成员内部类对象的两种方式：</p><p>方式一：当成员内部类被private修饰时：在外部类编写方法，对外提供内部类对象。</p><p>方式二：当成员内部类被非私有修饰时，直接创建对象。Outer.Inner oi&#x3D;new Outer().new Inner();</p></br><p>35、静态内部类：只能访问外部类中的静态变量和静态方法。如果想要访问非静态的需要创建外部类的对象。</p><p>创建静态内部类对象格式：外部类名.内部类名 对象名&#x3D;new 外部类名.内部类名（）</p><p>调用静态方法的格式：外部类名.内部类名.方法名（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>&#123;<br>            Outer o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>            sout(a);  <span class="hljs-comment">//会报错,能访问外部类中的静态变量</span><br>            sout(o.a); <span class="hljs-comment">//这样才能访问到</span><br>            sout(b);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>()&#123;<br>    psvm&#123;<br>        <span class="hljs-comment">//只要是静态的东西，都可以用类名点直接获取</span><br>        Outer.Inner oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br>        oi.show1()<br>        <span class="hljs-comment">//静态方法可以直接.获取</span><br>        Outer.Inner.show2()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></br><p>36、匿名内部类：可以写在成员位置，也可以写在局部位置。</p><p>格式：new 类型或接口名（）{</p><p>​重写方法；</p><p>}；</p><p>细节：整体就是一个类的子类对象或者接口的实现类对象。</p><p>使用场景：当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只使用一次，就可以用匿名内部类简化代码。</p></br><p>37、System工具类</p><p>exit(int status)：终止当前运行的java虚拟机</p><p>currentTimeMillis()：返回当前系统的时间毫秒值形式</p><p>arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数)：数组拷贝</p><p>arraycopy注意事项：如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，且拷贝时不能超出数组的长度，如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型。</p></br><p>38、Object和Objects</p><p>Object：</p><p>​toString()：一般会重写，打印对象时打印属性</p><p>​equals()：比较对象时会重写，比较对象属性值是否相同</p><p>​clone()：默认浅克隆</p><p>Objects：工具类</p><p>​equals(对象1，对象2)：先做非空判断，比较两个对象</p><p>​isNull(对象)：判断对象是否为空</p></br><p>39、正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符类（只匹配一个字符）</span><br>[abc]  <span class="hljs-comment">//只能是a,b,c</span><br>[^abc] <span class="hljs-comment">//除了a,b,c之外的任何字符</span><br>[a-zA-z]  <span class="hljs-comment">//a到z A到Z，包括（范围）</span><br>[a-d[m-p]]  <span class="hljs-comment">//a到d，或m到p</span><br>[a-z&amp;&amp;[def]]  <span class="hljs-comment">//a到z和def的交集，也就是def</span><br>[a-z&amp;&amp;[^bc]]  <span class="hljs-comment">//a到z和非bc的交集，（等同于[ad-z]）</span><br>[a-z&amp;&amp;[^m-p]] <span class="hljs-comment">//a到z和除了m到p的交集（等同于[a-lp-z]）</span><br><br><span class="hljs-comment">//预定义（只匹配一个字符）</span><br>.  <span class="hljs-comment">//任何字符</span><br>\d  <span class="hljs-comment">//一个数字：[0-9]</span><br>\D  <span class="hljs-comment">//非数字：[^0-9]</span><br>\s  <span class="hljs-comment">//一个空白字符：[\t\n\x0B\f\r]</span><br>\S  <span class="hljs-comment">//非空白字符:[^\s]</span><br>\w  <span class="hljs-comment">//[a-zA-z_0-9] 英文、数字、下划线</span><br>\W  <span class="hljs-comment">//[^\w]一个非单词字符</span><br><br><span class="hljs-comment">//数量词</span><br>?       <span class="hljs-comment">//一次或0次</span><br>*       <span class="hljs-comment">//0次或多次</span><br>+       <span class="hljs-comment">//一次或多次</span><br>&#123;n&#125;     <span class="hljs-comment">//正好n次</span><br>&#123;n,&#125;    <span class="hljs-comment">//至少n次</span><br>&#123;n,m&#125;   <span class="hljs-comment">//至少n但不超过m次</span><br><br><span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>  <span class="hljs-comment">//手机号码</span><br><span class="hljs-string">&quot;0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;&quot;</span>  <span class="hljs-comment">//座机号</span><br><span class="hljs-string">&quot;\\w+@[\\w&amp;&amp;[^_]]&#123;2,6&#125;(\\.[a-zA-z]&#123;2,3&#125;)&#123;1,2&#125;&quot;</span>      <span class="hljs-comment">//邮箱</span><br></code></pre></td></tr></table></figure></br><p>40、包装类：用一个对象，把基本数据类型给包起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>Integer n=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//JDK5以前，包装类相加要先拆箱转为基本数据类型，相加后在进行装箱</span><br>Integer i1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>i1.intValue()+i2.intValue();<br>Integer i3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(result);<br><br><span class="hljs-comment">//JDK提出一个机制：自动装箱和自动拆箱</span><br><span class="hljs-comment">//自动装箱：把基本数据类型会自动变成其对应的包装类</span><br>Integer i1=<span class="hljs-number">10</span>;<br><span class="hljs-comment">//自动拆箱：把包装类自动的变成其对象的基本数据类型</span><br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//自动拆箱的动作</span><br><span class="hljs-type">int</span> i=i2;<br><span class="hljs-comment">//JDK以后，int和Integer可以看做是同一个东西，因为在内部可以自动转化。</span><br><span class="hljs-comment">//写法</span><br>Integer i1=<span class="hljs-number">10</span>;<br>Integer i2=<span class="hljs-number">10</span>;<br>Integer i3=i2+i3;<br><br></code></pre></td></tr></table></figure></br><p>41、集合进阶：</p><p>单列集合：Collection，它的功能是全部单列集合都可以继承使用的。</p><p>Collection分为List系列集合和Set系列集合</p><p>List系列集合：添加的元素是有序（不是指排序，是指放入和拿出元素顺序一致）、可重复、有索引</p><p>Set系列集合：无序、不重复、无索引</p><p>注意：Collection是一个接口，不能直接创建他的对象，只能创建他的实现类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; coll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()； <span class="hljs-comment">//多态的形式</span><br></code></pre></td></tr></table></figure><p>Collection遍历方式（for循环必须要用索引，所以只适用于list系列集合，不适用set系列集合）</p><ol><li><p>迭代器遍历：不依赖索引。类名Iterator，集合专用的遍历方式，hasNext()判断当前位置是否元素，有返回true，没有返回false。  next()获取当前位置的元素，并将迭代器对象移向下一个位置。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it=list.iterator();    <span class="hljs-comment">//创建指针</span><br>white(it.hasNext())&#123;   <span class="hljs-comment">//判断是否有元素</span><br>    String str=it.next();    <span class="hljs-comment">//获取元素，引动指针</span><br>    sout(str);<br>&#125;<br></code></pre></td></tr></table></figure><p> 迭代器遍历完毕，指针不会复位。循环中只能用一次next()。迭代器遍历时，不能用集合的方法进行增删。</p></li><li><p>增强for遍历：底层就是迭代器，所有的单列集合和数组才能用增强for进行遍历。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s:list)&#123;<br>sout(s);<br>&#125;<br><span class="hljs-comment">//修改增强for中的变量，不会改变集合中原本的数据。</span><br><span class="hljs-keyword">for</span>(元素的数据类型 变量名：数组或者集合)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>​五种遍历方式对比：</p><p>​1、迭代器遍历：在遍历的过程中需要删除元素，请使用迭代器。</p><p>​2、列表迭代器：在遍历的过程中需要添加元素，请使用列表迭代器。</p><p>​3、增强for遍历和Lambda表达式：仅仅想遍历。</p><p>​4、普通for遍历：如果遍历的时候想操作索引。</p></br><p>42、数据结构：</p><ol><li>栈（后进先出，先进后出）</li><li>队列（先进先出，后进后出）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java从0开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
