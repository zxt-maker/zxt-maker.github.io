<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录美好的一天天~（2025）</title>
    <link href="/2025/08/20/zxt2025/"/>
    <url>/2025/08/20/zxt2025/</url>
    
    <content type="html"><![CDATA[<p>​现在是北京时间的2025年8月20日，阔别2年后，我又重新拾起了这个博客嘿嘿。而且，我也娶到了我的大猪蹄子，话不多说，直接上图👇</p><center>   <div style="text-align:center;">        <img src="../img/zxt2025/739095d47a54c1dec6bab25fe1317e6a.png" alt="13" width="600"  />    </div></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录美好的一天天~（2023）</title>
    <link href="/2023/06/27/zxt/"/>
    <url>/2023/06/27/zxt/</url>
    
    <content type="html"><![CDATA[<h6 id="2023-4-1（台州临海）"><a href="#2023-4-1（台州临海）" class="headerlink" title="2023.4.1（台州临海）"></a>2023.4.1（台州临海）</h6><p>​1.一大早开着我的特特和我的bb出发啦~</p><center>   <div style="text-align:center;">        <img src="../img/zxt/7a54b8e82b31b04b91abecd50ec9de8.jpg" alt="7a54b8e82b31b04b91abecd50ec9de8" width="600"  />    </div></center></br><p>​2.经过两个多小时到达了台州临海紫阳街，天气很好。</p><center>    <div style="text-align:left;">        <img src="../img/zxt/df808bc8016cfaf3d9d51b2ef59a362.jpg" alt="df808bc8016cfaf3d9d51b2ef59a362" width="350" />        <img src="../img/zxt/ce0aa8359e5813d87ab76bb1603e31e.jpg" alt="ce0aa8359e5813d87ab76bb1603e31e" width="350" />    </div></center></br><p>​3.吃了那边很多的小吃，吃了蛋清羊尾，梅花糕，排队买的海苔饼一口没吃，因为那边的东西太顶了。</p><center>    <div style="text-align:center;">       <img src="../img/zxt/8afa826d60db2e687b8f45fd0dcc290.jpg" alt="8afa826d60db2e687b8f45fd0dcc290" width="350" />        <img src="../img/zxt/2768989c609d492d43d9367181b2aeb.jpg" alt="2768989c609d492d43d9367181b2aeb" width="350" />    </div></center><center>    <div style="text-align:center;">      <img src="../img/zxt/e76cdc40ec9806a275ce3f939e2db6d.jpg" alt="e76cdc40ec9806a275ce3f939e2db6d" width="350" />       <img src="../img/zxt/978b0461bb7a1af5c3bdd0547ccd09b.jpg" alt="978b0461bb7a1af5c3bdd0547ccd09b" width="350"  />    </div></center></br><p>​4.这是bb在小红薯上看到的很多人推荐的寿司店，我觉得味道一般，服务态度满分~</p><center>   <div style="text-align:center;">        <img src="../img/zxt/0364a8e4dfd33194f931a320b36d597.jpg" alt="0364a8e4dfd33194f931a320b36d597" width="600"  />    </div></center><p>​</p><br/><p>5.bb抓拍镜头下的我，唉，果然人帅怎么都好看。</p><center>   <div style="text-align:center;">        <img src="../img/zxt/92048ffa782d076200ce3d9c7ec78ae.jpg" alt="92048ffa782d076200ce3d9c7ec78ae" width="600" />    </div></center><br/><p>​Ending：这是今年的第一次自驾”远门”，原本想着住一晚，可惜台州实在没啥好留宿一天的理由，还是我大宁波好。</p><h6 id="2023-4-30（温州鹿城）"><a href="#2023-4-30（温州鹿城）" class="headerlink" title="2023.4.30（温州鹿城）"></a>2023.4.30（温州鹿城）</h6><p>​1.五一大家都出去玩，朋友有自驾去厦门的，福州的，我嘛，带着bb去趟温州，顺便见见zjr~</p><center>   <div style="text-align:center;">       <img src="../img/zxt/303ddd0d3016f9cae4994cce3b7cf59.jpg" alt="303ddd0d3016f9cae4994cce3b7cf59" width="600" />    </div></center></br><p>​2.当晚就让zjr开着他的E300座驾来接我们去吃饭，去吃了一家长这么大吃过最好吃的龙虾店（可能是因为龙虾非常新鲜，冰镇龙虾真的绝绝子，图片只剩下些残羹了，忘记拍了~）</p><center>   <div style="text-align:center;">      <img src="../img/zxt/0bb85e8ec10252af4e13c838fb8a9fd.jpg" alt="0bb85e8ec10252af4e13c838fb8a9fd" width="600" />    </div></center></br><p>​3.吃完饭去逛了下南街，说实话和宁波的南塘老街一模一样，甚至不如哈哈，夜色挺好，但是没拍照，八嘎。</p></br><p>​4.第二天zjr带着我们去吃了他高中经常吃的糯米饭（排队的人很多，大家都3,4个甚至6,7个一起买），然后吃了个东北菜就回家啦~，东北菜也没拍照，只能上上好吃的糯米饭团了，味道还可以，应该热的更好吃，我们是晚上回去的路上才吃的，已经冷啦！</p><center>    <div style="text-align:center;">     <img src="../img/zxt/960245767365bf413bf0e16f433adcd.jpg" alt="960245767365bf413bf0e16f433adcd" width="350" />       <img src="../img/zxt/7519719eafb7a42785396889bc6fcf5.jpg" alt="7519719eafb7a42785396889bc6fcf5" width="350" />    </div></center></br><p>​5.回去路上偷拍了bb。</p><center>   <div style="text-align:center;">     <img  src="../img/zxt/aaf7453edd8f3813e38c4fe7e6d9487.jpg" alt="aaf7453edd8f3813e38c4fe7e6d9487" width="600" />    </div></center></br><h6 id="2023-5-13-湖州"><a href="#2023-5-13-湖州" class="headerlink" title="2023.5.13(湖州)"></a>2023.5.13(湖州)</h6><p>​1.提前一个多月买了莫干山奇幻音乐节门票，一大早就出发啦~到的时候已经下午了，先去吃个午饭，去了当地比较火的苍蝇馆子福至煲，可能是因为饿的关系，饿的时候吃啥都好吃，前几口觉得真好吃，后面就觉得有点腻了，特色薯条味道也一般般。</p><center>    <div style="text-align:center;">   <img src="../img/zxt/b53d003c38b3b202ff38c2bd27f45cd.jpg" alt="b53d003c38b3b202ff38c2bd27f45cd" width="600" />    </div></center></br><p>​2.吃完饭就去衣裳街走了走，去吃了比较火的小萝栗和徐忠良定胜糕，这些玩意儿也就第一口好吃，可是买起来至少10个起步，也不知道我排队买小萝栗时前面几个人6.7盒的买是咋想的。</p><center>    <div style="text-align:center;">    <img src="../img/zxt/5ee465632b9604898a148e6a5101a0e.jpg" alt="5ee465632b9604898a148e6a5101a0e" width="350" />      <img src="../img/zxt/c62702bd2382f1ece4bd62434da677b.jpg" alt="c62702bd2382f1ece4bd62434da677b" width="350" />    </div></center></br><p>​3.晚上去吃了湖州的状元楼，说实话味道不如宁波的，逼格也不如宁波的，点了5个菜，也就烂糊鳝丝味道还可以，但我觉得不如阿毛饭店的鳝丝哈哈哈哈哈哈。</p><center>    <div style="text-align:center;">   <img width="350" src="../img/zxt/002d89e260e453d5c2fb93be4a9281b.jpg" alt="002d89e260e453d5c2fb93be4a9281b" />     <img src="../img/zxt/1995c931c421c3a47f3febc03c72897.jpg" alt="1995c931c421c3a47f3febc03c72897" width="350" />    </div></center></br><p>​4.吃完晚饭后去月亮湾走了走，不得不说晚上的月亮湾拍出来还是很美的。</p><center>    <div style="text-align:center;">        <img src="../img/zxt/4c0f5eecc86d30f82df939688eb8586.jpg" alt="4c0f5eecc86d30f82df939688eb8586" width="350" />        <img src="../img/zxt/6e28282807c1ad7b7a34bea20112e43.jpg" alt="6e28282807c1ad7b7a34bea20112e43" width="350" />    </div></center><p>​</p></br><p>​5.第二天出发去音乐啦，有我最喜欢的杨和苏。</p><center>    <div style="text-align:center;">        <img src="../img/zxt/8f4e52f3365ec38f59e7a7404fd6204.jpg" alt="8f4e52f3365ec38f59e7a7404fd6204" width="350"  />       <img src="../img/zxt/bd9e44106491fb0cce1f9c3d0480a31.jpg" alt="bd9e44106491fb0cce1f9c3d0480a31" width="350" />    </div></center></br><p>沙一汀~</p><p>（以下都是视频，打不开谷歌浏览器对着视频右键选择显示所有控件就可以播放啦~）</p><center>    <video width="100%" src="../img/zxt/sha.mp4"></video></center></br><p>姜云升，印象中只有他的浪漫主义。</p><center>    <video width="100%" src="../img/zxt/jiang.mp4"></video></center></br><p>杨和苏！一上场就让他脱，这小子还装矜持，最后还不是乖乖脱了哈哈，这身材我做为一个男的都爱了~</p><center>    <video width="100%" src="../img/zxt/yanghesu1.mp4"></video></center><center>    <video width="100%" src="../img/zxt/yanghesu2.mp4"></video></center><center>    <div style="display:flex;">        <video style="flex:1;" width="350" src="../img/zxt/yanghesu3.mp4"></video>        <img style="flex:1;" src="../img/zxt/15f0498f366dd253d25cced084b68df.jpg" alt="15f0498f366dd253d25cced084b68df" width="350" />    </div></center></br><p>TT，感觉还是前几年在长沙yolo唱的好听，可能那时还比较战斗，现在开始走情歌路线了，最后压轴还是唱了party是我家，之前听过，可惜那晚为了躲避高峰提早先走啦~</p><center>    <video width="100%" height="500" src="../img/zxt/tt.mp4"></video></center></br><p>​5.看完音乐节去安吉住了一晚，不多说了，都是泪，除了山就是山。</p><center>    <div style="text-align:center;">       <img width="600" src="../img/zxt/image-20230523082634286.png" alt="image-20230523082634286" />    </div></center></br><h6 id="2023-5-20（520快乐bb-）"><a href="#2023-5-20（520快乐bb-）" class="headerlink" title="2023.5.20（520快乐bb~）"></a>2023.5.20（520快乐bb~）</h6><center>    <div style="text-align:center;">     <img src="../img/zxt/438b7ce7d26e3f7fe739d7f237e77ef.jpg" alt="438b7ce7d26e3f7fe739d7f237e77ef" width="600" />    </div></center><h6 id="2023-9-16-2023-9-19（北京）"><a href="#2023-9-16-2023-9-19（北京）" class="headerlink" title="2023.9.16~2023.9.19（北京）"></a>2023.9.16~2023.9.19（北京）</h6><p>​1、第一天头铁一大早做了7小时高铁，到酒店贴贴后就去吃晚饭啦，第一餐那必须是铜锅涮肉，尝一尝北京的麻酱（不符合我的口味），吃完去三里屯逛了逛。PS：酒店很不错，羊肉也就那样，可能是找的店不够地道，三里屯就那样，除了人还是人，买不起的还是买不起。</p><center>     <div style="text-align:center;">        <img src="../img/zxt/63b51ab5883d8d7aea6bb7051232fd1.jpg" alt="63b51ab5883d8d7aea6bb7051232fd1" width="350" />        <img src="../img/zxt/a896b7e66b3aa9b712a0ba77948ca02.jpg" alt="a896b7e66b3aa9b712a0ba77948ca02" width="350" />    </div></center></br><p>​2、第二天一大早（快10点了）就出发去天安门，故宫啦，北京嘛，这些地方那是必须去滴。拍照，打卡。</p><center>     <div style="text-align:center;">        <img src="../img/zxt/4d71b0fc42040e574f7d1105d70fdca.jpg" alt="4d71b0fc42040e574f7d1105d70fdca" width="350" />        <img src="../img/zxt/4a0b4c100cce8a4b1415fa46ad36116.jpg" alt="4a0b4c100cce8a4b1415fa46ad36116" width="350" />    </div></center></br><p>​当然少不了靓仔美女的照片啦。（我拍照技术还可以吧）</p><center>     <div style="text-align:center;">        <img src="../img/zxt/8b3dd9b6fec173b1a594f2f22ce81f7.jpg" alt="8b3dd9b6fec173b1a594f2f22ce81f7" width="350" />        <img src="../img/zxt/65e63140a1121ccb1cd907478df4281.jpg" alt="65e63140a1121ccb1cd907478df4281" width="350" />    </div></center><center>     <div style="text-align:center;">        <img src="../img/zxt/dba92b4b5f505f9cb4fdd772ac8400a.jpg" alt="dba92b4b5f505f9cb4fdd772ac8400a" width="350" />        <img src="../img/zxt/a6049c380bee75c72bf1262aded7fba.jpg" alt="65e63140a1121ccb1cd907478df4281" width="350" />    </div></center><center>     <div style="text-align:center;">        <img src="../img/zxt/16dc9e2ce67129c6a8f8e34c4bb7f3a.jpg" alt="16dc9e2ce67129c6a8f8e34c4bb7f3a" width="350" />        <img src="../img/zxt/e2ee273d9e83fd633937bff90d99bed.jpg" alt="e2ee273d9e83fd633937bff90d99bed" width="350" />    </div></center></br><p>​穿过故宫就是景山公园啦，只需要沿着指示牌上山（大概10分钟）就可以看到故宫全貌，真的非常壮观。</p><center>    <div style="text-align:center;">     <img src="../img/zxt/195ed4ac4086a97399bceb8742174cf.jpg" alt="195ed4ac4086a97399bceb8742174cf" width="600" />    </div></center></br><p>​故宫回来在酒店点了卤煮（门框胡同百年卤煮），味道很不错，图1是酒店早餐（酒店真不错，还有健身房，可惜缺了个激发我潜力的小伙伴，身边是个废柴😶）。</p><center>     <div style="text-align:center;">        <img src="../img/zxt/5664b12d596ef2e3e8f48be4a660b0a.jpg" alt="5664b12d596ef2e3e8f48be4a660b0a" width="350" />        <img src="../img/zxt/2e3e1f0d3e9b056a7a7dce0388852b1.jpg" alt="2e3e1f0d3e9b056a7a7dce0388852b1" width="350" />    </div></center></br><p>​3、第三天，原本想去爬长城的，完全没想到长城在这么偏的地方，交通实在不方便，那么就弥补下自己的味蕾。来北京嘛，那必须得来吃烤鸭，豆汁焦圈。安排。</p></br><p>​第一站先去了一家馒头店，听宝说很有名，话不多说，上图，好多人都十个二十个买，还都是当地的老奶奶老大爷，哪想必味道肯定不错。</p><center>     <div style="text-align:center;">        <img src="../img/zxt/130381e97eb89d45bbe7fdbd16cd8b3.jpg" alt="130381e97eb89d45bbe7fdbd16cd8b3" width="350" />        <img src="../img/zxt/44b76090c7ae532105f5b2265ffd52d.jpg" alt="44b76090c7ae532105f5b2265ffd52d" width="350" />    </div></center><p>​</br></p><p>​马不停蹄的就去吃烤鸭店啦，刷了小红书和抖音，最终选择了四季民福（故宫店）</p><center>     <div style="text-align:center;">        <img src="../img/zxt/f06706292ea71ed19128ff5e46e3ba9.jpg" alt="f06706292ea71ed19128ff5e46e3ba9" width="350" />        <img src="../img/zxt/cfac0d6f929e0565ac6a30ec9f249f0.jpg" alt="cfac0d6f929e0565ac6a30ec9f249f0" width="350" />    </div></center><p>​</br></p><p>​豆汁是真难喝啊，不过去之前就已经做好了心理建设，所以喝到的时候也没有想象中的那么难以入口下咽，我觉得味道有点像酸的生萝卜带点臭。</p></br><p>​下午去了杨梅竹斜街（充满了北京胡同气息，有三轮车的老大爷全程讲解，听到是180一个人，里面有很多的书法和字画店，奈何我是个糙人，就当在刷步数啦），大栅栏（更有商业气息，有一条步行街，有很多游客在此吃喝游玩）。</p><center>     <div style="text-align:center;">        <img src="../img/zxt/2f96f47753f2962cc82559392b410a9.jpg" alt="2f96f47753f2962cc82559392b410a9" width="350" />        <img src="../img/zxt/265ade13b3e0d800f089d78a9787ac4.jpg" alt="265ade13b3e0d800f089d78a9787ac4" width="350" />    </div></center><center>     <div style="text-align:center;">        <img src="../img/zxt/b7ab6b354b947a26c98c253d55d9f0f.jpg" alt="b7ab6b354b947a26c98c253d55d9f0f" width="350" />        <img src="../img/zxt/d5d96ca7bbc7c5445c70ccc9ab2f1df.jpg" alt="d5d96ca7bbc7c5445c70ccc9ab2f1df" width="350" />    </div></center></br><p>​4、最后一天，闪现回我大宁波。</p><center>    <div style="text-align:center;">     <img src="../img/zxt/d74399bb017b75988285e20985869d8.jpg" alt="d74399bb017b75988285e20985869d8" width="600" />    </div></center></br><p>最后的最后：总结一下，北京不是很好玩，但是肯定是值得去滴。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE基础进阶</title>
    <link href="/2023/05/29/JavaSE/"/>
    <url>/2023/05/29/JavaSE/</url>
    
    <content type="html"><![CDATA[<p>1、双列集合：</p><p>​双列集合一次需要存储一对数据，分别为键和值，键不能重复，值可以重复，两者一一对应。</p><p>​Map是双列集合的顶层接口。</p><p><img src="/../img/JavaSE/image-20230531090850837.png" alt="image-20230531090850837"></p><p>​put方法除了添加还有覆盖的功能，再添加数据时，如果键不存在，直接把键值对对象添加到map集合中，方法返回null，如果键存在，会把原来的键值对对象覆盖，并把覆盖的值进行返回。</p><p>Map遍历方式：</p><ol><li>键找值（map.keySet()将键放入一个单列集合，在去找值）</li><li>键值对（map.entrySet()，返回键值对对象，再用getKey()获取键，getValue()获取值）。</li><li>lambda表达式map.forEach((key,value)-&gt;{})。（底层就是第二种方法）</li></ol></br><p>HashMap:（无序、不重复、无索引）</p><ol><li>底层也是哈希表结构的</li><li>依赖HashCode方法和equals方法保证<strong>键的唯一</strong></li><li>如果键存储的是自定义对象，需要重写HashCode方法和equals方法，如果值存储的是自定义对象，不需要重写HashCode方法和equals方法。</li></ol><p>linkedHashMap:（有序、不重复、无索引）</p><p>TreeMap:（可排序、不重复、无索引）</p><ol><li>底层和TreeSet一样，都是红黑树结构</li><li>可排序：<strong>对键进行排序</strong>（1、实现Comparable接口，指定比较规则。2、创建集合时传递Comparator比较器对象，指定比较规则。）</li></ol></br><p>​1.TreeMap添加元素的时候，键是否需要重写hashCode和equals方法？ 不需要，跟HashMap的键有关。</p></br><p>​2.HashMap是哈希表结构的，JDK8开始由数组，链表和红黑树组成的。既然有红黑树，HashMap的键是否需要实现Compareable接口或者传递比较器对象呢？ 不需要，因为在HashMap的底层，默认是利用哈希值的大小关系来创建红黑树的。</p></br><p>​3.TreeMap和HashMap谁的效率更高？  如果是最坏的情况，添加了8个元素，这8个元素形成了链表，此时TreeMap的效率更高，但是这种情况的几率非常的少，一般而言还是HashMap的效率更高。</p></br><p>​4.三种双列集合，以后如何选择？  默认HashMap（效率最高） ，如果要保证存取有序：LinkedHashMap，如果要进行排序：TreeMap</p></br><p>2、可变参数：</p><p>​格式：属性类型…名字  如int…args，底层就是一个数组，java帮我们创建好。</p><p>​细节：</p><ol><li>在方法的形参中最多只能写一个可变参数。</li><li>如果方法中出现了可变参数以外的其他参数，那么可变参数要写在最后。</li></ol></br><p>3、Collections：集合工具类</p><img src="../img/JavaSE/image-20230607095335805.png" alt="image-20230607095335805" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>Collections.addAll(list,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;bcd&quot;</span>,<span class="hljs-string">&quot;sad&quot;</span>,<span class="hljs-string">&quot;sdad&quot;</span>,<span class="hljs-string">&quot;asd&quot;</span>,<span class="hljs-string">&quot;abasdasdc&quot;</span>);<br><br><br></code></pre></td></tr></table></figure></br><p>4、不可变集合：</p><p>​创建的书写格式：在List，Map，Set接口中，都存在静态的of方法，可以获取一个不可变的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list=List.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>);<br><span class="hljs-comment">//一旦创建完成，是无法进行修改的，只能进行查询操作。</span><br></code></pre></td></tr></table></figure><p>​Map的of方法，参数是有上限的，最多只能传递20个参数，10个键值对。</p><p>​如果要创建Map的不可变集合，键值对的数量超过10个，用Map.ofEntries()(JDK8不支持，JDK9才有，要高版本)。还有Map.copyOf()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、创建一个Map集合</span><br>HashMap&lt;String,String&gt; hm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>    hm.put(<span class="hljs-string">&quot;张三&quot;</span>+i,<span class="hljs-string">&quot;nanjing&quot;</span>+i);<br>&#125;<br>System.out.println(hm);<br><span class="hljs-comment">//2、利用上面的数据来获取一个不可变的集合</span><br><span class="hljs-comment">//获取到所有的键值对对象(Entry对象)</span><br>Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = hm.entrySet();<br><span class="hljs-comment">//把entries变成一个数组</span><br>Map.Entry[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>.Entry[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//toArray方法在底层会比较集合的长度和数组的长度</span><br><span class="hljs-comment">//如果集合的长度&gt;数组的长度，数据在数组中放不下，此时会根据实际数据的个数，重新创建数组</span><br><span class="hljs-comment">//如果集合的长度&lt;=数组的长度：此时不会常见新的数组，直接用。</span><br>Map.Entry[] arr2 = entries.toArray(arr1);<br><br>Map mp=Map.ofEntries(arr2);<br><br><span class="hljs-comment">//等同于上面代码,要JDK10以上</span><br>Map&lt;String,String&gt; map=Map.copyOf(hm);<br></code></pre></td></tr></table></figure></br><p>5、Stream流</p><p>​作用：结合Lambda表达式，简化集合、数组的操作</p><p>​使用步骤：1、先得到一条Stream流，并把数据放上去。2、利用Stream流中的API进行各种操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//单列集合获取Stream流</span><br>    ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Collections.addAll(list,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>    list.stream().forEach(name-&gt;&#123;<br>        System.out.println(name);<br>    &#125;);<br>    <span class="hljs-comment">//双列集合无法直接使用stream流，要先用keySet()或者entrySet()转换为单列集合</span><br>    HashMap&lt;String,String&gt; hm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    hm.put(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>);<br>    hm.put(<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-string">&quot;222&quot;</span>);<br>    hm.put(<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>);<br>    hm.put(<span class="hljs-string">&quot;ddd&quot;</span>,<span class="hljs-string">&quot;444&quot;</span>);<br>    hm.keySet().stream().forEach(name-&gt; System.out.println(name));<br>    hm.entrySet().stream().forEach(name-&gt; System.out.println(name));<br>    <span class="hljs-comment">//数组</span><br>    <span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    Arrays.stream(arr).forEach(name-&gt; System.out.println(name));<br>    <span class="hljs-comment">//零散数据，必须同类型</span><br>    <span class="hljs-comment">//stream接口静态方法of的细节：</span><br>    <span class="hljs-comment">//方法的形参时一个可变参数，可以传递一堆零散的数据，也可以传递数据</span><br>    <span class="hljs-comment">//但是数据必须是引用数据类型的，如果传递基本数据类型，会把整个数组当作一个元素，放到stream流中。</span><br>    Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).forEach(name-&gt; System.out.println(name));<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//保留年龄大于24的人，并将结果收集到Map集合，姓名为键，年龄为值</span><br>        ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan,23&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi,24&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;wangwu,25&quot;</span>);<br><br>        Map&lt;String, Integer&gt; collect = list.stream()<br>                .filter(s -&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">24</span>)<br>                .collect(Collectors.toMap(s -&gt; s.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>], s -&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>])));<br>        System.out.println(collect);<br>    &#125;<br></code></pre></td></tr></table></figure><p>6、方法引用</p><p>​把已经存在的方法拿来用，当做函数式接口钟抽象方法的方法体。</p><p>​::  方法引用符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> functionDemo;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">45</span>,<span class="hljs-number">3</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">34</span>,<span class="hljs-number">84</span>&#125;;<br><span class="hljs-comment">//倒叙</span><br>        Arrays.sort(arr,Demo1::subtraction);<br>        System.out.println(Arrays.toString(arr));<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtraction</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span>&#123;<br>         <span class="hljs-keyword">return</span> num2-num1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>引用成员方法：</p><p>​格式：对象::成员方法。</p><p>​其他类：其他类对象::方法名  </p><p>​本类：this::方法名（引用处不能是静态方法，因为静态方法内没有this和super）</p><p>​父类：super::方法名（引用处不能是静态方法，因为静态方法内没有this和super）</p><p>引用构造方法：</p><p>​格式：类名::new（Student::new）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> functionDemo;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 需求：集合里面存储姓名和年龄，要求封装成Student对象并收集到List集合中</span><br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, <span class="hljs-string">&quot;张无忌,12&quot;</span>, <span class="hljs-string">&quot;周芷若,14&quot;</span>, <span class="hljs-string">&quot;赵敏,13&quot;</span>);<br>        <span class="hljs-comment">// List&lt;Student&gt; collect = list.stream().map((s) -&gt; &#123;</span><br>        <span class="hljs-comment">//     String[] arr = s.split(&quot;,&quot;);</span><br>        <span class="hljs-comment">//     String name = arr[0];</span><br>        <span class="hljs-comment">//     int age = Integer.parseInt(arr[1]);</span><br>        <span class="hljs-comment">//     return new Student(age, name);</span><br>        <span class="hljs-comment">// &#125;).collect(Collectors.toList());</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// System.out.println(collect);</span><br><br>        List&lt;Student&gt; collect = list.stream().map(Student::<span class="hljs-keyword">new</span>).collect(Collectors.toList());<br>        System.out.println(collect);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>7、捕获异常：为了当代码出现异常时，<strong>可以让程序继续往下执行</strong>（<strong>更多用在方法调用处，不让程序停止</strong>）</p><p>try{</p><p>​可能出现异常的代码</p><p>}catch(异常类名 变量名){</p><p>​异常的处理代码；</p><p>}</p><img src="../img/JavaSE/image-20231031093535696.png" alt="image-20231031093535696" /><p>抛出处理：(<strong>更多用在方法处，告诉调用者出错了</strong>)</p><p>throws:写在方法定义处，表示声明一个异常，告诉调用者，使用本方法可能会有哪些异常</p><p>public void 方法() throws 异常类名1,异常类名2…{}</p><p>编译时异常：必须要写  运行时异常：可以不写</p><p>throw:写在方法内，结束方法，手动抛出异常对象，交给调用者，方法中下面的代码不再执行了</p><p>public void 方法(){</p><p>​throw new NullPointerException();</p><p>}</p><p>8、IO流：存储和读取数据的解决方案</p><p>作用：读取数据</p><p>输出流：程序→文件</p><p>输入流：文件→程序</p><p>字符流：底层就是字节流+字符集。特点：一次读一个字节，遇到中文时，一次读多个字节。</p><p>缓冲流：</p><p>​字节缓冲输入流：BufferedInputStream</p><p>​字节缓冲输出流：BufferedOutputStream</p><p>​字符缓冲输入流：BufferedReader</p><p>​字符缓冲输入流：BufferedWriter</p><p>字符缓冲流两个特有的方法：BufferedReader  ：readline（）</p><p>​  BufferedWriter：newline（）</p><img src="../img/JavaSE/image-20231110141044484.png" alt="image-20231110141044484" /><p> 常用工具包：commons-io FileUtils工具类</p><p>9、多线程</p><p>​并发：在同一时刻，有多个指令在单个CPU上交替执行</p><p>​并行：在同一时刻，有多个指令在多个CPU上同时执行</p></br><p>同步代码块（锁）：</p><p>​1、锁默认打开，有一个线程进去了，锁自动关闭。</p><p>​2、里面的代码全部执行完毕，线程出来，锁自动打开。</p><p>格式：</p><p>​&#x2F;&#x2F;锁对象一定要是唯一的，可以在对象前加static关键字</p><p>​synchronized（锁对象）{</p><p>​操作共享数据的代码</p><p>​}</p></br><p>10、网络编程</p><p>三要素：ip、端口号、协议</p><p>ip:设备在网络中的地址，是唯一的标识</p><p>端口号：应用程序在设备中唯一的标识</p><p>协议：数据在网络中传输的规则，常见的有UDP、TCP、http、https、ftp</p><p>特殊的ip:172.0.0.1（永远表示本机）</p><p>UDP协议：面向无连接通信协议（速度快，数据不安全，容易丢失数据）</p><p>TCP:协议：面向连接的通信协议（速度慢，数据安全）</p></br><p>11、反射</p><p>获取class对象的三种方式：</p><p>1、Class.forName(“全类名”)   &#x2F;&#x2F;最为常用</p><p>2、类名.class   &#x2F;&#x2F;更多是当作参数进行传递</p><p>3、对象.getClass()   &#x2F;&#x2F;当有了这个类的对象时，才可以使用。</p></br><p>12、动态代理</p><p>通过接口保证，后面的对象和代码需要实现同一个接口。</p><p>接口中就是被代理的所有方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SE基础第二阶段</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JaveWeb</title>
    <link href="/2023/03/27/JaveWeb/"/>
    <url>/2023/03/27/JaveWeb/</url>
    
    <content type="html"><![CDATA[<p>1、Maven（管理和构建java项目的工具）</p><p>作用：方便依赖管理、统一项目结构、标准化项目构建。</p><p>配置：</p><p>​在<dependencies>标签中使用<dependency>引入坐标</p><p>主要生命周期：</p><p>​clean：清理  compile：编译 test：测试package：打包install：安装</p><p>2、Http协议</p><p>​基于TCP协议：面向连接，安全</p><p>​基于请求-响应模型的：一次请求对应一次响应</p><p>​Http协议是无状态的协议：对于事物处理没有记忆能力。每次请求-响应都是独立的。</p><p>​缺点：多次请求间不能共享数据。  优点：速度快。</p><p>3、springboot</p><p>简单参数：参数名和形参变量名相同，定义形参即可接收参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;simpleParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name,Integer age)</span>&#123;<br>    sout(name+<span class="hljs-string">&quot;:&quot;</span>+age);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RequestParam注解：方法形参名称与请求参数名称不匹配，通过该注解完成映射。默认属性为true，代表请求参数必须传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;simpleParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name=&quot;name&quot;)</span> String username,Integer age)</span>&#123;<br>    sout(username+<span class="hljs-string">&quot;:&quot;</span>+age);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、</p><p>@RestController&#x3D;@Controller+@ResponseBoby（响应数据）；</p><p>统一响应结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&#123;<br><span class="hljs-comment">//响应码，1代表成功，0代表失败</span><br>    <span class="hljs-keyword">private</span> Interger code;<br>    <span class="hljs-comment">//提示信息</span><br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-comment">//返回的数据</span><br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、分层解耦</p><p>三层架构：</p><p>​1、controller：控制层，接受前端发送的请求，对请求进行处理，并响应数据</p><p>​2、service：业务逻辑层，处理具体的业务逻辑</p><p>​3、dao：数据访问层（持久层），负责数据访问操作，包括数据的增删改查。</p><p>分层解耦：</p><p>控制反转：简称IOC，对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转</p><p>依赖注入：简称DI，容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><p>Bean对象：IOC容器中创建、管理的对象，称之为bean</p><p>​<strong>1、Service层及Dao层的实现类，交给IOC容器管理</strong></p><p>​<strong>2、为Controller及Service注入运行时，依赖的对象。</strong></p><p>​在需要依赖的类上增加@component：将当前类交给IOC容器管理，成为IOC容器中的bean（控制反转）</p><p>​在类中引用的对象（变量）上增加@Autowired：运行时，IOC容器会提供该类型的bean对象，并赋值给该变量（依赖注入）</p><p>@component衍生三个注解：@controller（@RestController已经包含了，所以在controller层写了@RestController无需再写@controller）、@Service（Service层使用）、@Repository（Dao层使用）</p></br><p>@Autowired注解，默认是按照类型进行，如果存在多个同类型的bean会报错</p><p>通过以下几种方案来解决：</p><p>@Primary：在需要使用的类上增加</p><p>@Qualifier：在@Autowired加（@Qualifier（”bean的名字”）（bean的名字，默认为类名的首字母小写））</p><p>@Resource：在Controller层中使用：@Resource（name&#x3D;”bean的名字”）</p><p>面试题：**@Resource和@Autowired的区别**</p><p>1、@Autowired是spring框架提供的注解，而@Resource是JDK提供的注解。</p><p>2、@Autowired默认是按照类型注入，而@Resource默认是按照名称注入</p></br><p>6、mysql中常见的数据类型：主要分为三类：数值类型、字符串类型、日期时间类型</p><p>insert语法</p><p>指定字段添加数据：insert into 表名（字段名1，字段名2） values（值1，值2）；</p><p>全部字段添加数据：insert into 表名 values（值1，值2）；</p><p>批量添加字段（指定字段）：insert into 表名（字段名1，字段名2） values（值1，值2），（值1，值2）；</p><p>批量添加字段（全部字段）：insert into 表名  values（值1，值2），（值1，值2）；</p><p>update语法</p><p>update 表名 set 字段名1&#x3D;值1，字段名2&#x3D;值2，….[where 条件]</p><p>delete语法</p><p>delete from 表名 ….[where 条件]</p><p>DQL语法（查）</p><p>select 字段列表 from 表名列表where 条件列表 group by 分组字段列表having 分组后条件列表</p><p>order by排序字段列表limit 分页参数</p><p>查询多个字段：select 字段1，字段2… from 表名；</p><p>查询所有字段：select  *  from 表名；</p><p>设置别名：select 字段1 [as 别名1]，字段2 [as 别名2]… from 表名；（as可省略）</p><p>去除重复记录：select distinct 字段列表 from 表名；</p><p>条件查询：select 字段1，字段2… from 表名where条件列表；</p><p>between…and…（在某个范围之内，（含最小值、最大值））</p><p>in(…)  （在in之后的列表中的值，多选一）</p><p>like 占位符（模糊匹配（_匹配单个字符，%匹配任意个字符））</p><p>is null 是null</p><p>查询姓名为两个字的员工信息：select * from tb_emp where name like ‘__’;</p><p>查询姓’张’的员工信息：select * from tb_emp where name like ‘张%’;</p><p>DDL分组查询：</p><p>select 字段列表 from 表名【where 条件】 group by 分组字段名 【having 分组后过滤条件】;</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</p><p>执行顺序：where&gt;聚合函数&gt;having</p><p>面试题：<strong>where和having的区别</strong></p><p>1、执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组，而having是分组之后对结果进行过滤。</p><p>2、判断条件不同：where不能对聚合函数进行判断，而having可以。</p><p>DQL-排序查询：</p><p>select 字段列表 from 表名 【where 条件列表】【group by 分组字段】 order by 字段1 排序方式1，字段2 排序方式2…;ASC：升序（默认值） DESC：降序</p><p>DQL-分页查询：select 字段列表 from 表名 limit 起始索引，查询记录数；</p><p>注意事项：</p><p>1、起始索引从0开始，起始索引&#x3D;（页码数-1）*每页显示记录数。</p><p>2、分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是limit。</p><p>3、如果查询的是第一页数据，其实索引可以省略，直接简写成limit 10.</p></br><p>7、多表设计</p>]]></content>
    
    
    
    <tags>
      
      <tag>制作中小型网站&amp;企业管理系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE基础</title>
    <link href="/2023/03/27/Java/"/>
    <url>/2023/03/27/Java/</url>
    
    <content type="html"><![CDATA[<p>1、JDK：Java开发工具包，包括JVM虚拟机，核心类库，开发工具。JRE：Java运行环境。JDK包含了JRE，JRE包含了JVM。</p></br><p>2、class：创建&#x2F;定义一个类，类是Java最基本的组成单元。</p></br><p>3、计算机三原色：红、绿、蓝&#x3D;》rbg。</p></br><p>4、数据类型：</p><p>​整型：byte、short、int（默认）、long。定义long类型的变量，在数值后面需要加一个L作为后缀，可以大写也可以小写。</p><p>​浮点数：float、double（默认），float后缀同理要加一个F</p><p>​字符：char　　　　　　　布尔：Boolean</p></br><p>5、Java键盘录入的类：Scanner。</p></br><p>6、byte、short、char三种类型数据在运算时，会先提升为int，在进行运算</p></br><p>7、数组初始化：</p><p>​静态初始化：int[] arr&#x3D;{1,2,3,4,5}</p><p>​动态初始化：int[] arr&#x3D;new int[5]  -&gt;代表五个</p></br><p>8、方法重载：方法名相同，参数类型或个数不同。Java虚拟机会通过参数不同来区分同名的方法。</p></br><p>9、类名首字母建议大写。</p></br><p>10、封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为。例子：人画圆，画圆事件封装在圆对象上。</p></br><p>11、private关键词：是一个权限修饰符，可以修饰成员（成员变量和方法），被private修饰的成员只能在本类中才能访问。对象内部通过get和set进行变量操作。</p></br><p>12、构造方法推荐使用方式：无论是否使用，都手动书写无参构造方法和带全部参数的构造方法。（IDEA快捷创建：alt+insert指令。）</p></br><p>13、比较字符串对象中的内容是否相等：equals(完全一样)，equalsIgnoreCase(忽略大小写)</p></br><p>14、统计一个字符串中有多少大写字符、小写字符、数字字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> bigCount=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> smallCount=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> numberCount=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length();i++)&#123;<br>    <span class="hljs-type">char</span> c=str.charAt(i);<br>    <span class="hljs-comment">//char类型的变量在参与计算的时候自动类型提升为int，查询ascii码表</span><br>    <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>        smallCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>        bigCount++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>        numberCount++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>15、StringBuilder：可以看成是一个容器，创建之后里面的内容是可变的（String定义后的字符串不可变）</p><p>​作用：提高字符串的操作效率。</p><p>StringBuilder是Java已经写好的类，打印对象不是地址值而是属性值。</p><p>最后要用toString()方法把StringBuilder变回字符串。</p><p>使用场景：字符串的拼接、字符串的反转。</p></br><p>​<strong>String对象的改变，实际上是通过内存地址的“断开-连接”变化来完成的。在这个过程中，原字符串中的内容并没有发生任何的改变。String s &#x3D; “yiyige” 和 s &#x3D; “yyg”这两行代码，实质上是开辟了2个内存空间，s只是由原来指向 “yiyige” 变为指向 “yyg” 而已，而其原来的字符串内容，是没有发生改变的。</strong></p><p>​<strong>所以String的不可变，其实是指value在栈中的引用地址不可变，而不是说常量池中value字符数组里的数据元素不可变。也就是说，value所引用的数组对象里的内容，其实是可以发生改变的。</strong></p><p>​<strong>String字符串的内容其实是可变的，不可改变的只是String字符串的对象地址。</strong></p><p>​<strong>因此，我们在以后的开发中，如果要经常修改字符串的内容，请尽量少用String！因为如果字符串的指向经常的“断开-连接”，就会大大降低性能，我建议大家使用StringBuilder 或 StringBuffer 进行替换。</strong></p></br><p>16、集合和数组的区别：</p><p>​1、数组长度固定，集合长度可变。</p><p>​2、数组可以存储引用数据类型和基本数据类型，集合只能存储引用数据类型，要想存储基本数据类型，需要将基本数据类型转化成对应的包装类。</p><p>​泛型：限定集合中存储数据的类型。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <span class="hljs-comment">//JDK7以前的写法</span><br><br>ArrayList&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//JDK7以后的写法，可以省略后面的类型，&lt;&gt;要写</span><br><br><span class="hljs-comment">//添加元素，返回一个Boolean，永远为true</span><br>list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>list.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>list.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-comment">//删除元素</span><br>list.remove(<span class="hljs-string">&quot;aaa&quot;</span>);  <span class="hljs-comment">//删除成功返回true，失败返回false</span><br>list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">//根据索引删除元素，返回被删除的元素</span><br><span class="hljs-comment">//修改元素</span><br>list.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ddd&quot;</span>);  <span class="hljs-comment">//返回被修改的元素</span><br><span class="hljs-comment">//查询元素</span><br>list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回被查询的元素</span><br><span class="hljs-comment">//获取长度</span><br>list.size();<br><br></code></pre></td></tr></table></figure></br><p>17、基本数据类型对应的包装类</p><p>​byte-&gt;Byte　　 　short-&gt;Short 　　　<strong>char-&gt;Character　　　 int-&gt;Integer</strong> 　　　long-&gt;Long 　　　float-&gt;Float 　double-&gt;Double 　　boolean-&gt;Boolean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>ArrayList&lt;Character&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></br><p>18、static特点：被该类所有对象共享，<strong>不属于对象，属于类</strong>，<strong>随着类的加载而加载，优先于对象存在</strong>。</p><p>调用方式：推荐使用类名调用，也可以对象名调用。</p></br><p>19、继承：Java只支持<strong>单继承</strong>，不支持<strong>多继承</strong>，但支持<strong>多层继承</strong>：子类A继承父类B，子类B继承父类C。</p><p>Java中所有的类都直接或者间接继承于<strong>Object</strong>类。子类只能访问父类非私有的成员。</p><p>父类的构造方法不能被子类继承。</p><p>父类的成员变量无论是否私有，在子类中都可以<strong>继承</strong>下来，但是<strong>如果是父类的私有成员变量，子类无法调用</strong>。</p><p>父类的成员方法只有在<strong>虚方法表</strong>中才能把被子类继承。</p><p>虚方法表：非private，非static，非final修饰的方法。</p><p>继承中成员变量访问特点：<strong>就近原则。</strong>现在局部位置找，本类成员位置找，父类成员位置找，逐级往上。</p><p>super关键字：直接去父类中找成员变量或方法。</p></br><p>20、方法重写：子类出现了和父类一模一样的方法生命，我们就称子类这个方法是重写的方法。</p><p>建议重写方法都加**@Override<strong>注解。</strong>只有被添加到虚方法表中的方法才能被重写。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>    sout(<span class="hljs-string">&quot;zzz&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>21、子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。</p><p>原因：子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成吃实话，子类将无法使用父类的数据。因此子类初始化前，一定要调用父类构造方法先完成父类数据空间的初始化。</p><p><strong>子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行。</strong></p></br><p>22、多态：对象的多种形态。</p><p>前提：有继承&#x2F;实现关系。有父类引用指向子类对象。有方法的重写。</p><p>好处：<strong>使用父类型作为参数，可以接收所有子对象。</strong>体现多态的扩展性与便利。</p><p>弊端：不能使用子类的特有功能。</p><p>解决方法：自动类型转换、强制类型转换，可以转换成真正的子类类型，从而调用子类独有功能。</p><p>转换类型与真实对象类型不一致会报错。</p><p>转换的时候用instanceof关键字进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//自动类型转换</span><br>Student s=(Student) p;   <span class="hljs-comment">//强制类型转换</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多态形式创建对象</span><br>Fu f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br><span class="hljs-comment">//调用成员变量的特点：编译看左边，运行也看左边。</span><br><span class="hljs-comment">//调用成员方法的特点：编辑看左边，运行看右边。</span><br><span class="hljs-comment">//编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量或方法，如果有，编辑成功，如果没有，编辑失败。</span><br><span class="hljs-comment">//运行看左边：java运行代码的时候，实际获取的是左边父类中成员变量的值。</span><br><span class="hljs-comment">//运行看右边；java运行代码的时候，实际上运行的是子类中的方法。</span><br><br><span class="hljs-comment">//理解：Animal A=new Dog();</span><br><span class="hljs-comment">//现在用a去调用变量和方法？是的</span><br><span class="hljs-comment">//而a是Animal类型的，所以默认都会从Animal这个类中找</span><br><br><span class="hljs-comment">//成员变量：在子类的对象中，会把父类的成员变量也继承下来。父：name,子：name</span><br><span class="hljs-comment">//成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的。</span><br><br></code></pre></td></tr></table></figure></br><p>23、使用同一个包中的类时，不需要导包。</p><p>使用java.lang包中的类时，不需要导包。</p><p>其他情况都需要导包。</p><p>如果同时用两个包中的同名类，需要用全类名。</p></br><p>24、final关键词：</p><p>修饰方法：表明该方法时最终方法，不能被重写。</p><p>类：表明该类时最终类，不能被继承。</p><p>变量：叫做常量，只能被赋值一次。</p><p>final修饰基本数据类型，记录的值不能发生改变，修饰引用数据类型，记录的地址值不能发生变化，内部的属性值是可以改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Student S=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">14</span>)；<br>S=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sutdent</span>();  <span class="hljs-comment">//会报错</span><br>S.setName(<span class="hljs-string">&quot;李四&quot;</span>);  <span class="hljs-comment">//不会报错，并且可以修改成功。</span><br></code></pre></td></tr></table></figure></br><p>25、权限修饰符分类 </p><p>四种作用范围从小到大（private&lt;空着不写&lt;protected&lt;public）</p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中其他类</th><th>不同包下的子类</th><th>不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>空着不写</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></br><p>26、静态代码块作用：数据初始化。</p></br><p>27、抽象方法：</p><p>​将<strong>共性的</strong>行为（方法）抽取到父类之后。</p><p>​由于每一个子类执行的内容是不一样。</p><p>​所以，在父类中不能确定<strong>具体的方法体</strong>。</p><p>​该方法就可以定义为抽象方法。</p><p>抽象类：如果一个<strong>类中存在抽象方法</strong>，那么该类就<strong>必须声明为抽象类</strong></p><p>抽象类不能实例化。</p></br><p>28、接口：就是一种规则，是对行为的抽象。</p><p>用关键词interface来定义。 public interface 接口名{}</p><p>接口不能实例化。接口和类之间是实现关系，通过implements关键词表示。</p><p>public class 类名 implements 接口名{}</p><p>接口和类的实现关系，可以单实现也可以多实现。</p><p>public class 类名 implements 接口名1，接口名2{}</p><p>实现类还可以在继承一个类的同时实现多个接口。</p><p>public class 类名 extends 父类 implements 接口名1，接口名2{}</p></br><p>29、接口中成员的特点：</p><p>成员变量：只能是常量。默认修饰符：public static final</p><p>构造方法：没有。</p><p>成员方法：只能是抽象方法，默认修饰符：public abstract</p></br><p>30、类和类的关系：继承关系，只能单继承，但可以多层继承。</p><p>类和接口的关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口。</p><p>接口和接口的关系：继承关系，可以单继承，也可以多继承。</p></br><p>31、JDK8以前，接口只能定义抽象方法。JDK8<strong>允许在接口中定义默认方法和静态方法，需要使用关键词default和static修饰。</strong>作用：<strong>解决接口升级的问题</strong>。JDK9允许接口定义私有方法，分为普通的私有方法（为default默认方法服务）和静态的私有方法（为static静态方法服务），作用：抽取重复代码并在接口内部使用，不让外部访问。</p><p>接口中默认方法的定义格式：</p><ol><li>格式：public default 返回值类型 方法名（参数列表）{}</li><li>范例：public default void show（）{}</li></ol><p>接口中默认方法的注意事项：</p><ol><li>默认方法不是抽象方法，所以不强制被重写，但如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略，不写的话会被默认当成抽象方法。</li><li>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></br><p>32、当一个方法参数是接口时，可以传递接口<strong>所有实现类的对象</strong>，这种方式称之为接口多态。</p></br><p>33、内部类：在一个类中又定义了一个类。</p><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。</p><p>特点：内部类可以直接访问外部类的成员，包括私有。外部类要访问内部类的成员，必须创建对象。</p></br><p>34、获取成员内部类对象的两种方式：</p><p>方式一：当成员内部类被private修饰时：在外部类编写方法，对外提供内部类对象。</p><p>方式二：当成员内部类被非私有修饰时，直接创建对象。Outer.Inner oi&#x3D;new Outer().new Inner();</p></br><p>35、静态内部类：只能访问外部类中的静态变量和静态方法。如果想要访问非静态的需要创建外部类的对象。</p><p>创建静态内部类对象格式：外部类名.内部类名 对象名&#x3D;new 外部类名.内部类名（）</p><p>调用静态方法的格式：外部类名.内部类名.方法名（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span>&#123;<br>            Outer o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>            sout(a);  <span class="hljs-comment">//会报错,能访问外部类中的静态变量</span><br>            sout(o.a); <span class="hljs-comment">//这样才能访问到</span><br>            sout(b);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>()&#123;<br>    psvm&#123;<br>        <span class="hljs-comment">//只要是静态的东西，都可以用类名点直接获取</span><br>        Outer.Inner oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br>        oi.show1()<br>        <span class="hljs-comment">//静态方法可以直接.获取</span><br>        Outer.Inner.show2()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></br><p>36、匿名内部类：可以写在成员位置，也可以写在局部位置。</p><p>格式：new 类型或接口名（）{</p><p>​重写方法；</p><p>}；</p><p>细节：整体就是一个类的子类对象或者接口的实现类对象。</p><p>使用场景：当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只使用一次，就可以用匿名内部类简化代码。</p></br><p>37、System工具类</p><p>exit(int status)：终止当前运行的java虚拟机</p><p>currentTimeMillis()：返回当前系统的时间毫秒值形式</p><p>arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数)：数组拷贝</p><p>arraycopy注意事项：如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，且拷贝时不能超出数组的长度，如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型。</p></br><p>38、Object和Objects</p><p>Object：</p><p>​toString()：一般会重写，打印对象时打印属性</p><p>​equals()：比较对象时会重写，比较对象属性值是否相同</p><p>​clone()：默认浅克隆</p><p>Objects：工具类</p><p>​equals(对象1，对象2)：先做非空判断，比较两个对象</p><p>​isNull(对象)：判断对象是否为空</p></br><p>39、正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符类（只匹配一个字符）</span><br>[abc]  <span class="hljs-comment">//只能是a,b,c</span><br>[^abc] <span class="hljs-comment">//除了a,b,c之外的任何字符</span><br>[a-zA-z]  <span class="hljs-comment">//a到z A到Z，包括（范围）</span><br>[a-d[m-p]]  <span class="hljs-comment">//a到d，或m到p</span><br>[a-z&amp;&amp;[def]]  <span class="hljs-comment">//a到z和def的交集，也就是def</span><br>[a-z&amp;&amp;[^bc]]  <span class="hljs-comment">//a到z和非bc的交集，（等同于[ad-z]）</span><br>[a-z&amp;&amp;[^m-p]] <span class="hljs-comment">//a到z和除了m到p的交集（等同于[a-lp-z]）</span><br><br><span class="hljs-comment">//预定义（只匹配一个字符）</span><br>.  <span class="hljs-comment">//任何字符</span><br>\d  <span class="hljs-comment">//一个数字：[0-9]</span><br>\D  <span class="hljs-comment">//非数字：[^0-9]</span><br>\s  <span class="hljs-comment">//一个空白字符：[\t\n\x0B\f\r]</span><br>\S  <span class="hljs-comment">//非空白字符:[^\s]</span><br>\w  <span class="hljs-comment">//[a-zA-z_0-9] 英文、数字、下划线</span><br>\W  <span class="hljs-comment">//[^\w]一个非单词字符</span><br><br><span class="hljs-comment">//数量词</span><br>?       <span class="hljs-comment">//一次或0次</span><br>*       <span class="hljs-comment">//0次或多次</span><br>+       <span class="hljs-comment">//一次或多次</span><br>&#123;n&#125;     <span class="hljs-comment">//正好n次</span><br>&#123;n,&#125;    <span class="hljs-comment">//至少n次</span><br>&#123;n,m&#125;   <span class="hljs-comment">//至少n但不超过m次</span><br><br><span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>  <span class="hljs-comment">//手机号码</span><br><span class="hljs-string">&quot;0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;&quot;</span>  <span class="hljs-comment">//座机号</span><br><span class="hljs-string">&quot;\\w+@[\\w&amp;&amp;[^_]]&#123;2,6&#125;(\\.[a-zA-z]&#123;2,3&#125;)&#123;1,2&#125;&quot;</span>      <span class="hljs-comment">//邮箱</span><br></code></pre></td></tr></table></figure></br><p>40、包装类：用一个对象，把基本数据类型给包起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>Integer n=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//JDK5以前，包装类相加要先拆箱转为基本数据类型，相加后在进行装箱</span><br>Integer i1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>i1.intValue()+i2.intValue();<br>Integer i3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(result);<br><br><span class="hljs-comment">//JDK提出一个机制：自动装箱和自动拆箱</span><br><span class="hljs-comment">//自动装箱：把基本数据类型会自动变成其对应的包装类</span><br>Integer i1=<span class="hljs-number">10</span>;<br><span class="hljs-comment">//自动拆箱：把包装类自动的变成其对象的基本数据类型</span><br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//自动拆箱的动作</span><br><span class="hljs-type">int</span> i=i2;<br><span class="hljs-comment">//JDK以后，int和Integer可以看做是同一个东西，因为在内部可以自动转化。</span><br><span class="hljs-comment">//写法</span><br>Integer i1=<span class="hljs-number">10</span>;<br>Integer i2=<span class="hljs-number">10</span>;<br>Integer i3=i2+i3;<br><br></code></pre></td></tr></table></figure></br><p>41、集合进阶：</p><p>单列集合：Collection，它的功能是全部单列集合都可以继承使用的。</p><p>Collection分为List系列集合和Set系列集合</p><p>List系列集合：添加的元素是有序（不是指排序，是指放入和拿出元素顺序一致）、可重复、有索引</p><p>Set系列集合：无序、不重复、无索引（不能通过普通for循环遍历，也不能通过索引获取元素）</p><p>​HashSet：无序、不重复、无索引</p><p>​LinkedHashSet：<strong>有序</strong>、不重复、无索引（<strong>底层数据结构依然是哈希表</strong>，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。）</p><p>​TreeSet：<strong>可排序</strong>、不重复、无索引（<strong>底层数据结构是红黑树</strong>。对于数值类型默认规则从小到大，对于字符、字符串按照在ASCII码表中的数字升序进行排序）</p><p>注意：Collection是一个接口，不能直接创建他的对象，只能创建他的实现类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; coll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()； <span class="hljs-comment">//多态的形式</span><br></code></pre></td></tr></table></figure><img src="../img/Java/image-20230529150544244.png" alt="image-20230529150544244" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个Set集合的对象</span><br>Set&lt;String&gt; s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-type">boolean</span> r1=s.add(<span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-type">boolean</span> r2=s.add(<span class="hljs-string">&quot;张三&quot;</span>);<br>s.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>s.add(<span class="hljs-string">&quot;王五&quot;</span>);<br><span class="hljs-comment">//Set集合不能重复。因此可以用来去重。</span><br>sout(r1);   <span class="hljs-comment">//true</span><br>sout(r2);   <span class="hljs-comment">//false</span><br>sout(S);    <span class="hljs-comment">//[李四，张三，王五]，存和取不同，因此无序。</span><br><br></code></pre></td></tr></table></figure></br><p>哈希值</p><p>​哈希值：对象的整数表现形式</p><p>​1、如果没有重写HashCode方法，计算出的哈希值是不同的</p><p>​2、如果已经重写HashCode方法，不同的对象只要属性值相同，计算出来的哈希值是一样的。</p><p>​3、小部分情况下，不同属性或者不同地址值计算出来的哈席子也可能一样（哈希碰撞）。</p><p>HashSet集合底层采取哈希表存储数据结构。</p></br><p>Collection遍历方式（for循环必须要用索引，所以只适用于list系列集合，不适用set系列集合）</p><ol><li><p>迭代器遍历：不依赖索引。类名Iterator，集合专用的遍历方式，hasNext()判断当前位置是否元素，有返回true，没有返回false。  next()获取当前位置的元素，并将迭代器对象移向下一个位置。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it=list.iterator();    <span class="hljs-comment">//创建指针</span><br>white(it.hasNext())&#123;   <span class="hljs-comment">//判断是否有元素</span><br>    String str=it.next();    <span class="hljs-comment">//获取元素，引动指针</span><br>    sout(str);<br>&#125;<br></code></pre></td></tr></table></figure><p> 迭代器遍历完毕，指针不会复位。循环中只能用一次next()。迭代器遍历时，不能用集合的方法进行增删。</p></li><li><p>增强for遍历：底层就是迭代器，所有的单列集合和数组才能用增强for进行遍历。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s:list)&#123;<br>sout(s);<br>&#125;<br><span class="hljs-comment">//修改增强for中的变量，不会改变集合中原本的数据。</span><br><span class="hljs-keyword">for</span>(元素的数据类型 变量名：数组或者集合)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>​五种遍历方式对比：</p><p>​1、迭代器遍历：在遍历的过程中需要删除元素，请使用迭代器。</p><p>​2、列表迭代器：在遍历的过程中需要添加元素，请使用列表迭代器。</p><p>​3、增强for遍历和Lambda表达式：仅仅想遍历。</p><p>​4、普通for遍历：如果遍历的时候想操作索引。</p></br><p>42、泛型进阶：</p><p>​如果没有给集合指定类型，默认所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型。但是会带来一个坏处：我们在获取数据时，无法使用它的特有行为。此时推出泛型，在添加数据时进行统一，省的强转，非常方便。</p><p>​java中的泛型是伪泛型。</p><p>​泛型中不能写基本数据类型。</p><p>​指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型。</p><p>​泛型不具备继承性，但是数据具备继承性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建集合对象</span><br>psvm()&#123;<br>    ArrayList&lt;Ye&gt; list1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    ArrayList&lt;Fu&gt; list2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    ArrayList&lt;Zi&gt; list3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//调用method方法,泛型不具备继承性</span><br>    method(list1);<br>    method(list2);  <span class="hljs-comment">//报错</span><br>    method(list3);  <span class="hljs-comment">//报错</span><br>    <span class="hljs-comment">//但是数据具备继承性</span><br>    <span class="hljs-comment">//不报错</span><br>    list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Ye</span>());<br>    list2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fu</span>());<br>    list3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>());<br>&#125;<br><br><span class="hljs-comment">//此时泛型里面写的什么类型，那么只能传递什么类型的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(ArrayList&lt;Ye&gt; list)</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ye</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> extents Ye&#123;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> extents Fu&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>​泛型通配符？也表示不确定的类型，但可以进行类型的限定</p><p>​？extends E：表示可以传递E或者E所有的子类类型</p><p>​？super E：表示可以传递E或者E所有的父类类型</p><p>应用场景：</p><p>​1、如果在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。</p><p>​2、如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以使用泛型的通配符。</p></br><p>43、数据结构：</p><ol><li><p>栈（后进先出，先进后出）</p></li><li><p>队列（先进先出，后进后出）</p></li><li><p>数组：查询速度快：通过查询地址值和索引定位。删除效率低，后面每个数据要前移，添加效率极低，添加位置后每个数据后移。</p></li><li><p>链表：链表中的节点都是独立的对象，在内存中是不连续的，每个结点包含数据值和下一个结点的地址。链表查询慢，无论查询哪个数据都要从头开始找。但是<strong>链表的增删相对快</strong></p></li><li><p>ArrayList集合，底层数据结构是数组。</p></li><li><p>LinkedList集合：底层数据结构是双链表，查询慢，增删快，但如果操作的是首尾元素，速度也是极快的，本身有很多直接操作首尾元素的特有API。</p> </br></li></ol><p>​二叉查找树：又称二叉排序树或者二叉搜索树。</p><p>​特点：每一个节点上最多有两个子节点，任意节点左子树上的值都小于当前节点，任意节点右子树上的值都大于当前节点。</p><p>​遍历方式：</p><p>​前序遍历：当前节点，左子节点，右子节点</p><p>​中序遍历：左子节点，当前节点，右子节点</p><p>​后序遍历：左子节点，右子节点，当前节点</p><p>​层序遍历：一层一层的去遍历</p><p>红黑树：是一个二叉查找树，满足特有的红黑规则。</p><p>​红黑规则：</p><ol><li>每一个节点必须是红色或者黑色。</li><li>根节点必须是黑色。</li><li>如果一个节点没有子节点或者父节点，该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的。</li><li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）。</li><li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点；</li></ol><img src="../img/Java/image-20230529143834825.png" alt="image-20230529143834825" /><p>​添加节点时，默认是红色（效率高）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java从0开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
